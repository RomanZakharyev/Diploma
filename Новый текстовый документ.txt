import numpy as np
#import scipy.integrate as ode
import matplotlib.pyplot as plt

Y0 = np.array([0.5, 0.05, 0.0, 0.3, 0.1, 0.0]) #здесь задаем нач. условия в точке пространства, 
#откуда хотим вывести характеристику. x, y, z, v_x, v_y, v_z соответственно
dt = -2 * 10 ** (-3) #шаг времени. Отрицательный, потому что мы хотим посмотреть, какую скорость имела частица
#на границе гелиосферы в прошлом, откуда она прилетела
mu = 1.2 #значение mu. Больше единицы - сила отталкивания. Меньше единицы - притяжения. Имеет смысл тестить при мю = 0.9 и 1.2
G_hat =  1 - mu #безразмерный грав. параметр. Тут все норм
V_star = 2.64 * 10 ** 4 
L_star = 1.496 * 10 ** 11
alpha = (6.67 * 10 ** (-11) * 2 * 10 ** 30 * G_hat) / (V_star ** 2 * L_star)

x = Y0[0] 
y = Y0[1]
z = Y0[2]
v_x = Y0[3]
v_y = Y0[4]
v_z = Y0[5]

r = np.sqrt(x ** 2 + y ** 2 + z ** 2)
r_initial = np.sqrt(x ** 2 + y ** 2 + z ** 2)
v_initial = np.sqrt(v_x ** 2 + v_y ** 2 + v_z ** 2)

x_res = [x] #профессионально задаю массив с начальными условиями, куда потом будут кидаться решения при различных t
y_res = [y]
z_res = [z]
v_x_res = [v_x]
v_y_res = [v_y]
v_z_res = [v_z]

i = 0 #число итераций, чтобы смотреть, когда сдохнет комп
#i < 5 * 10 ** 7 #тут мой комп подыхал, верю в твой


while (r < 100) and (i < 10 * 10 ** 6): #r = 100, потому что это граница гелиосферы, где я и хочу найти скорости частицы
    r = np.sqrt(x ** 2 + y ** 2 + z ** 2)
    #vs = np.sqrt(v_x ** 2 + v_y ** 2 + v_z ** 2) #эта строчка в целом не нужна
    
    dx = v_x * dt #система диффуров собственно
    dy = v_y * dt
    dz = v_z * dt
    dv_x = (-G_hat / (r ** 3)) * x * dt
    dv_y = (-G_hat / (r ** 3)) * y * dt
    dv_z = (-G_hat / (r ** 3)) * z * dt
    
    x += dx    #кастую рунге 1 порядка         
    y += dy
    z += dz
    v_x += dv_x
    v_y += dv_y
    v_z += dv_z
    
    x_res.append(x) #записываю значения в мои массивы и всё по новой
    y_res.append(y)
    z_res.append(z)
    v_x_res.append(v_x)
    v_y_res.append(v_y)
    v_z_res.append(v_z)
    
    i += 1

v_s = np.sqrt(v_x_res[-2] ** 2 + v_y_res[-2] ** 2 + v_z_res[-2] ** 2) #тут как раз считается скорость на границе, 
#как предпоследние элементы массива, возможно во всех 6 кавычках скобках должно быть -3 для корректности, 
#но общую картину это не поменяет, тк скорости на таких расстояниях уже не меняются
r_final = np.sqrt(x_res[-2] ** 2 + y_res[-2] ** 2 + z_res[-2] ** 2) #конеч радиус, чтобы удостовериться, где мы
true_v_s = np.sqrt(2 * (((v_x_res[0] ** 2 + v_y_res[0] ** 2 + v_z_res[0] ** 2) / 2) - (alpha / r_initial) + (alpha / r_final)))
#а этот параметр - посчитанная скорость на границе по ЗСЭ. Именно с ним я и сравниваю свой результат. Он адаптивный, 
#может считать для любого конечного расстояния, не обязательно 100. Можно играться и смотреть, как результаты становятся 
#отвратительными даже при небольших r
print(i)
print("Initial radius =", r_initial)
print("Final radius =", r_final)
print("Initial speed =", v_initial)
print("Final speed =", v_s)
print("True v_s =", true_v_s)
#print(r_final)
print("")
print(v_s / true_v_s * 100) #чем ближе к 100 - тем лучше. Ошибка больше 5% криминал, но здесь это не предел XD

plt.plot(x_res, y_res) #можно поиграться, выводя траектории, и смотреть, как с уменьшением шага dt они становятся точнее
plt.grid()
plt.show()